#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

#    This file is part of the atm_pred module.
#
#    The atm_pred module is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    The atm_pred module is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with atm_pred.  If not, see <http://www.gnu.org/licenses/>.

"""Mention that we excpect atm models generated by generate_atm_models.py.
Include what the format of the table in each csv file should be"""

import os

import numpy as np
from astropy.table import Table
from datetime_to_spectra import _get_suomi_data

__author__ = 'Daniel Perrefort'
__email__ = 'djperrefort@gmail.com'
__copyright__ = 'Copyright 2017, Daniel Perrefort'
__license__ = 'GPL V3'
__status__ = 'Development'

# Define necessary directory paths
ATM_MODEL_DIR = './atm_models' # Location of atmospheric transmission models


def _read_pwv_model():
    """Read the atmospheric model into memory

    Walk through the directory ENVIRONMENT['PWV_MODEL_DIR'] and load read the
    contents of each csv file into an astropy table. Create a dictionary of
    these tables using the airmass value of each table as keys.

    Returns:
        table_dict (list): A dictionary of astropy tables
    """

    file_list = os.listdir(ATM_MODEL_DIR)

    table_dict = {}
    for file in file_list:
        if file.endswith('.csv'):
            pwv_value = float(os.path.basename(file).split("_")[3])
            file_path = os.path.join(ATM_MODEL_DIR, file)
            table_dict[pwv_value] = Table.read(file_path)

    return table_dict

# Get a list of PWV values and wavelengths handled by the model
ATM_MODEL = _read_pwv_model()
PWV_VALS = list(ATM_MODEL.keys())
WAVELENGTHS = ATM_MODEL[min(ATM_MODEL.keys())]['wavelength']


def date_to_spectra(pwv_val, airmass=1, path=None):
    """Return a model of atmospheric transmission for a given date

    Docstirng will be finished once jess' code is available - 
    """

    pwv_val = pwv_val * airmass
    # Create a table used to store future results
    interp_table = Table(names=['wavelength', 'transmission'])

    for i, wvlngth in enumerate(WAVELENGTHS):
        modled_transmissions = [ATM_MODEL[pwv]['transmission'][i]
                                for pwv in PWV_VALS]

        transmission_spect = np.interp(pwv_val, PWV_VALS, modled_transmissions)
        interp_table.add_row([wvlngth, transmission_spect])

    if path is not None:
        if not path.endswith('.fits'):
            path += '.fits'

        interp_table.write(path, format='fits', overwrite=True)

    return interp_table

def pwv_data(year, path=None):
    """Return an astropy table of PWV measurements for a given year

    Returns an astropy table of perceptible water vapor measurements for a
    given year as measured by SuomiNet. Values are measured in units of mm. If
    values are available from multiple receivers, include separate columns for
    each receiver.

    Args:
        year (int): The year of the desired PWV data
        path (str): If specified, write data to a fits file at this path

    Returns:
        pwv_data (astropy.table.Table): A table of PWV values in mm
    """

    # Check for valid args
    if not isinstance(year, int):
        raise ValueError('Argument must be an integer.')
    
    if not (path is None or isinstance(path, str)):
        raise ValueError('Path must be a string object.')

    if not year > 2009:
        msg = 'There is no SuomiNet data available for KPNO before 2010'
        raise ValueError(msg)

    # Check if data is available for the given year
    fpath = os.path.join(PWV_TABLES, 'pwv_{0}.fits')
    if not os.path.isfile(fpath.format(year)):
        msg = 'There is no locally available SuomiNet data for {0}.'
        raise ValueError(msg.format(str(year)))

    data = Table.read(fpath.format(year))
    
    if path:
        if not path.endswith('.fits'):
            path += '.fits'

        data.write(path, format='fits', overwrite=True)

    return data


def nearest_value(date, path=None):
    """Search an astropy Table instance for matching datetime information

    Given a datetime, return the nearest percipitable water vapor measurment
    from SuomiNet as an astropy table. If values are available from multiple
    receivers, include separate columns for each receiver.

    Args:
        year (int): An astropy table to be searched
        path (str): If specified, write results to a fits file at this path

    Returns:
        result (Table): An astropy table with the search results
    """

    # Check for valid args
    if not isinstance(date, datetime):
        raise ValueError('Date must be a datetime object.')

    if not (path is None or isinstance(path, str)):
        raise ValueError('Path must be a string object.')

    # Get the appropriate data table
    data_table = pwv_data(date.year)

    # Find the nearest datetime in the table
    nearest = min(data_table["date"], key=lambda x:
                  abs(datetime.strptime(x, '%Y-%m-%dT%H:%M') - date))

    # Find the corresponding row number
    indx = list(data_table["date"]).index(nearest)
    result = data_table[indx]

    if path:
        if not path.endswith('.fits'):
            path += '.fits'

        Table(result).write(path, format='fits', overwrite=True)

    return result